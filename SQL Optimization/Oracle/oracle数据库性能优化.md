# 一、性能优化综述

## 1.1性能优化能力

- 一切的优化都要从**业务**出发 ★
- 学员对数据库优化有一个比较清晰的思路

- 能够客观的评价数据库的性能问题
- 能够比较顺利的定位到问题点
- 能够处理常见的性能问题

## 1.2 性能优化的原则

- 不是所有的数据库都需要（能够）优化
- 数据库库的性能，大多数都不是从数据库层面能够解决的
- **在不了解业务之前，不可能找到正确的优化思路**
- **优化要有一个度**，并不是“没有最优，只有更优”

## 1.3 导致性能问题的可能原因

- 错误的执行计划
  - 表没有正确的创建**索引** 
  - 表没有及时的分析
- 热块-------数据块的争用（反向索引？）
- 锁的阻塞------业务设计缺陷
- SQL解析消耗大量CPU ----变量绑定
- 低效的SQL -----SQL自身的问题
- 数据库整体负载过程----架构设计的问题

## 1.4 性能问题的定位

**原则**：尽可能从小范围分析问题

1. SQL层

   如果能从定位到SQL，就不要从会话层面分析

   工具 执行计划，10053,10046....

2. 会话层

   如果能定位到会话，就不要从系统层面分析

   V$SESSION,V$SESSTAT,V$SESSION_WAIT,V$SQL,V$LOCK，SQL_TRACE

3. 系统层

   如果无法定位任何性能问题，从系统层面入手

   AWR（STATSPACK）,OS tools(TOP,IOSTAT....)

## 1.5 不要迷恋优化器

业务逻辑 ---优化器无能为力

业务逻辑 ---CBO无能为力

**建议**：

- **不要迷信优化器，优化器永远无法知道你的业务需求**
  - 优化器永远无法按照你的业务需求来重写你的SQL语句。
  - 优化器只能在数学（集合）逻辑上做SQL的重写。
- **高效的SQL来自于对业务的理解和对SQL执行过程的理解。只有自己才能写出性能最好的sql脚本**

## 1.6 为什么高效的SQL这么难？

1. SQL语言本质上是集合的操作

   开发者要明白业务，知道sql脚本应该满足什么查询结果

2. 语言的效率，是SQL语言的最难的地方

   tablesan

   index range scan

   index fast scan

   nested loop join

   merge join

   hash join

3. 优化器机制开发者无法掌控

## 1.7 问题思考

1. **“单纯的数据库层面的优化是没有前途的”，你怎么看？**

   数据库的优化是根据**业务的需求**而定的，不是无缘无故的优化。

   单纯从数据库层面优化显然是不全面的。有的时候整个业务的瓶颈点不在数据库，单纯的优化数据库起不到作用。**从业务的角度来看系统是否满足需求，负载量是否是正常的，是不是由于数据增长量已经超出了承受能力，业务需求的改变。**

2. 当一个有性能问题的数据库摆在你的面前，作为责任人，你的处理思路是什么？

   1. 先要弄清楚数据库的类型是什么 OLTP 在线事务处理 or OLAP 在线分析系统，因为不同的数据库类型选择优化的方法也不同。例如 OLTP 强调系统的内存命中率，内存的效率决定数据库效率。
   2. 如果用户的并发数很大可扩大内存的容量缓存更多的数据，还可以调整data buffer cache、shared pool、[java](http://www.itpub.net/pubtree/?node=207) pool、large pool的大小及PGA大小包括sort区hash区等。
   3. 如果用户的在线请求数较多，可以尝试着进行SQL的变量绑定，缓解SQL的硬解析，当遇到成千上万的查询操作时，能够不经过解析过程直接使用缓存的 执行计划，那效率可以提高n倍。因为硬解析会做2个分析。第一 语法分析：检查代码的语法是否正确。第二 语义分析：检查代码执行的对象是否存在及对执行对象的权限是否有。解析过程十分的耗费CPU资源。
   4. 数据块的争用，是因为数据分配的不均匀造成的，可以使用hash算法平均打散到各个磁盘上来减少热块的产生。
   5. 还有很多系统性能间接的反应为数据库性能，例如 网络的延迟 主机的应用程序较多 没有采用中间件策略构建预处理缓冲池。
   6. 如果是OLAP 在线分析系统的话，当一个用户找你来说查询一张报表很慢，你可以通过用户会话来找到查询的SQL语句，检查这条语句逻辑上效率如何，可以使用Hint方式 来改变sql的执行计划，检查数据的访问方式，是走全表扫描还是走索引效率最高，调整SQL的执行计划，选择合适的索引。
   7. 因为SQL大多数就是集合的数学运算操作，SQL表的关联方式是不是最优化，哪种join最适合，这都是要考虑的范围。
   8. 当你手工测试完后，对表进行统计分析，看看优化器和你选的执行计划是不是相同的。
   9. CBO模式的选择，对于需要快速响应用户的请求，可以设置成first_rows(优先把部分数据返回)，对于用户响应不是很严格的业务，可以设置成all_rows（所有处理数据一次性返回。
   10. 如果系统的整体开销不大，可以考虑并行技术。
   11. 对于OLAP系统最直接的提高数据库性能方法增加磁盘I/O和CPU吞吐量，如果硬件搞不了，可以采用数据库压缩技术，减少空间提高I/O。
   12. 随着数据量的增加，以前不是问题的问题也变成了问题，对于OLAP系统SQL的效率决定数据库效率。
   13. 统计信息，索引，分区，迁移历史数据，ASM。
   14. vmstat 、iostat 的报告 查看 os层面是否正常工作,有异常则采取措。



# 二、锁

## 2.1 为什么会有锁？

没有并发就没有锁

## 2.2 锁的分类

- Enqueues（lock）：队列类型的锁，通常和业务相关的
- Latches：系统资源方面的锁，比如内存结构，SQL解析

### 2.2.1 Enqueues & Latches 对比

|        | Latch            | Lock                 |
| ------ | ---------------- | -------------------- |
| 队列性 | √                | ×                    |
| 时长   | 很短             | 可能很长             |
| 层面   | 数据库资源层     | 业务应用层           |
| 目的   | 保证资源的完整性 | 保证业务操作的完整性 |



## 2.3 Enqueues（lock）

Enqueue 是Oracle使用的另一种锁定机制，它更加复杂，**允许几个并发进程不同程度地共享某些资源**。任何可被并发使用的对象均可使用enqueue加以保护。一 个典型的例子是表的锁定，我们允许在一个表上有不同级别的共享。与latch不同之处在于，enqueue是使用操作系统特定的锁定机制，一个 enqueue允许用户在锁上存贮一个标记，来表明请求锁的模式。操作系统lock manager跟踪所有被锁定的资源，如果某个进程不能获取它所请求的那种锁，操作系统就把请求进程置于一个等待队列中，该队列按FIFO原则调度，而在 latches中是没有象enqueue中排序的等待队列，latch等待进程要么使用定时器来唤醒和重试，要么spin(只用于多处理器情况下)。

### 2.3.1 锁的原则

- 只有被修改时，行才会被锁定。
- 当一条语句修改了一条记录，只有这条记录上被锁定，在Oracle数据库中不存在锁升级。
- 当某行被修改时，它将阻塞别人对它的修改。
- 当一个事务修改一行时，将在这个行上加上行锁（TX），用于阻止其它事务对相同行的修改。
- 读永远不会阻止写。
- 读不会阻塞写，但有唯一的一个例外，就是select ...for update。
- 写永远不会阻塞读。
- 当一行被修改后，Oracle通过回滚段提供给数据的一致性读。

### 2.3.2 锁的类型

#### 2.3.2.1 TM锁（表锁）

发生在insert, update, delete以及select for update操作时，目的是保证操作能够正常进行，并且阻止其它人对表执行DDL操作。

**TM锁几种模式的互斥关系**

| 模式 | 名称                                                         | 锁定的sql                                           | 排斥的模式 | 允许的dml                                 |
| ---- | ------------------------------------------------------------ | --------------------------------------------------- | ---------- | ----------------------------------------- |
| 2    | 行级共享锁，其他对象只能查询这些数据                         | lock table table_name in row  share mode;           | 6          | select,insert,update，delete，for  update |
| 3    | 行级排他锁，在事务提交前不允许做DML操作                      | lock table table_name in row  exclusive mode;       | 4,5,6      | select,insert,update,delete，for  update  |
| 4    | 共享锁，不允许DML,但是允许其他用户发出select …from for update命令对表添加RS锁 | lock table table_name in share  mode;               | 3,5,6      | select                                    |
| 5    | 共享行级排他锁，不能对相同的表进行DML操作，也不能添加共享锁  | lock table table_name in share  row exclusive mode; | 3,4,5,6    | select                                    |
| 6    | 排他锁，其他用户不能对表进行任何的DML和DDL操作，该表上只能进行查询 | lock table table_name in  exclusive mode;           | 2,3,4,5,6  | select                                    |

#### 2.3.2.2 TX锁 【事务锁（行锁）】

对于正在修改的数据，阻止其它会话进行修改。

#### 2.3.2.3 RI锁

基于引用关系的锁定，当对具有**主外键**关系的表做DML操作时，锁定不单单发生在操作表上，相应的引用表 上也可能加上相应的锁定。

#### 2.3.2.4 死锁

两个会话互相持有对方资源导致死锁。

#### 2.3.2.5 结论

- 通过锁定，可以达到预期的业务需求。
- 通过对业务深入的分析，可以最大程度的避免不必要锁定的发生。

## 2.4 Latch

Latch是用于保护SGA（System Global Area）系统全局区中共享数据结构的一种**串行化**锁定机制。Latch的实现是与操作系统相关的，尤其和一个进程是否需要等待一个latch、需要等待多长时间有关。

 Latch 是一种能够极快地被获取和释放的锁，它通常用于保护描述buffer cache中block的数据结构。与每个latch相联系的还有一个清除过程，当持有latch的进程成为死进程时，该清除过程就会被调用。Latch 还具有相关级别，用于防止死锁，一旦一个进程在某个级别上得到一个latch，它就不可能再获得等同或低于该级别的latch。

当一个进程准备访问SGA中的数据结构时，它就需要获得一个latch。当进程获得latch后，它将一直持有该latch直到它不再使用此数据结构，这时latch才会被释放。可通过latch名称来区分它所保护的不同数据结构。

Oracle 使用元指令对latch进行操作, 当所需的latch已被其他进程持有时，执行指令进程将停止执行部分指令，直到该latch被释放为止。从根本上讲，latch防止并发访问共享数据结 构，由于设置和释放latch的指令是不可分割的，操作系统就可以保证只有一个进程获得latch，又由于这只是单条指令，所以执行速度很快。latch 被持有的时间是很短，而且提供了当持有者不正常中断时的清除机制，该清除工作是由Oracle后台进程PMON来完成的。

### 2.4.1 Latch 的目的

- 保证资源的串行访问：
  - 保护SGA的资源访问
  - 保护内存的分配
- 保证执行的串行化：
  - 保护关键资源的串行执行
  - 防止内存结构损坏

### 2.4.2 Latch 分类

```sql
select name from v$latchname;
```

latch有40余种，但作为DBA关心的主要应有以下几种：

  **Cache buffers chains latch**: 当用户进程搜索SGA寻找database cache buffers时需要使用此latch。

  **Cache buffers LRU chain latch**: 当用户进程要搜索buffer cache中包括所有 dirty blocks的LRU (least recently used) 链时使用该种latch。

  **Redo log buffer latch**: 这种latch控制redo log buffer中每条redo entries的空间分配。

  **Row cache objects latch**: 当用户进程访问缓存的数据字典数值时，将使用Row cache objects latch。

### 2.4.3 Latch 的机制

![image-20221027153327196](oracle数据库性能优化.assets/image-20221027153327196.png)

### 2.4.4 Latch的获取

#### 2.4.4.1  Willing-to-wait

如果所请求的latch不能立即得到，请求进程将等待一很短的时间后再次发出请求。进程一直重复此过程直到得到latch。

- **spin**：当一个会话无法获得需要的latch时，会继续使用CPU(CPU 空转），达到一个间隔后， 再次尝试申请latch，直到达到最大的重试次数。
- **sleep**：当一个会话无法获得需要的latch时，会等待一段时间（sleep)，达到一个间隔后，再次 尝试申请latch,如此反复，直到达到最大的重试次数。

#### 2.4.4.2 Immediate

如果所请求的latch不能立即得到，不会发生sleep或者spin，而是去获取其它可用的Latch继续执行下去。

#### 2.4.4.3 latch优化思路

Latch导致的性能问题，通常是一个系统层面的问题：

- AWR报告是一个比较好的入口
- 通过动态视图v$latch..可以分析当前系统的latch资源情况
- 确定争用最大的Latch
- 分析可能的原因
- 从应用层面和数据库层面考虑解决途径。

# 三、优化器

## 3.1 概述

优化器（Optimizer）是oracle数据库中内置的一个核心系统/核心组件/模块。目的是按照一定的判断原则来得到它认为的目标SQL在当前情形下最高的执行路径（Access Path），即为了得到目标SQL的执行计划。
依据选择执行计划时所用到的判断原则，优化器可以分为RBO和CBO：RBO(Rule-Based Optimizer)是基于规则的优化器。CBO(Cost-Based Optimizer)是基于成本的优化器。

在得到目标SQL的执行计划时，RBO所用的判断原则为一组内置的规则，这些规则是硬编码在Oracle 数据库的代码中的，RBO 会根据这些规则从目标SQL诸多可能的执行路径中选择一条 来作为其执行计划；
而CBO所用的判断原则为成本,CBO会从目标SQL诸多可能的执行路径中选择**成本值最小**的一条来作为其执行计划，各个执行路径的成本值是根据目标SQL语句所涉及的表、索引、列等相关对象的**统计信息**计算出来的。

oracle数据库里SQL语句的执行过程可以用下`图1-1`来表示：

![image-20221031190944971](oracle数据库性能优化.assets/image-20221031190944971.png)

**注意**：优化器的输入是经过解析后（检查目标SQL的语法、语义和权限）的目标SQL，输出是目标SQL的执行计划。

## 3.2 RBO & CBO

### 3.2.1 RBO

之前已经提到，基于规则的优化器（RBO）通过硬编码在Oracle数据库代码中的一系列固定的规则，来决定目标SQL的执行计划。具体来说就是这样: Oracle 会在代码里事先给各种类型的执行路径定一个等级，一共有15个等级，从等级1到等级15。并且Oracle会认为等级值低的执行路径的执行效率会比等级值高的执行效率要高，也就是说在RBO的眼里，等级1所对应的执行路径的执行效率最高，等级15所对应的执行路径的执行效率最低。在决定目标SQL的执行计划时，如果可能的执行路径不止一条，则RBO就会从该SQL诸多可能的执行路径中选择一条等级值最低的执行路径来作为其执行计划。

在Oracle数据库里，对于OLTP类型的SQL语句而言，显然通过ROWID来访问是效率最高的方式，而通过全表扫描来访问则是效率最低的方式。与之相对应的，RBO内置的等级1所对应的执行路径就是“single row by rowid (通过rowid来访问单行数据)”，而等级15所对应的执行路径则是“full table scan (全表扫描)”。

和CBO相比，RBO是有其明显缺陷的。在使用RBO的情况下，执行计划一旦出了问题，很难对其做调
整；另外，如果使用了RBO，则目标SQL的写法，甚至是目标SQL中所涉及的各个对象在该SQL文本中出现的先后顺序，都可能会影响RBO对于该SQL执行计划的选择。更糟糕的是，Oracle数据库中很多很好的特性、功能均不能在RBO下使用，因为RBO不支持。

只要出现如下情况，即使修改了优化器的模式或者使用了RULE Hint，oracle依然不回使用RBO，而是强制使用CBO：

- 目标SQL中涉及的对象有IOT（Index Origanized Table）
- 目标SQL中涉及的对象有分区表
- 使用了并行查询或着并行DML
- 使用了星型连接
- 使用了哈希连接
- 使用了索引快速全扫描
- 使用了函数索引
- ......

一旦RBO选择的执行计划并不是当前情形下最优的执行计划，我们很难对RBO选择的执行计划做调整，其中非常关键的一个原因就是不能使用Hint，使用了Hint就自动启用了CBO。

### 3.2.2 CBO

我们在3.2节中已经提到RBO 是有明显缺陷的，比如Oracle数据库中很多很好的功能、特性是RBO不支持的，RBO产生的执行计划很难调整等，但这些还不是最要命的，**RBO最大的问题在于它是靠硬编码在Oracle数据库代码中的一系列固定的规则来决定目标SQL的执行计划的，而并没有考虑目标SQL中所涉及的对象的实际数据量、实际数据分布等情况**，这样一旦固定 的规则并不适用于该SQL中所涉及的实际对象时，RBO根据固定规则产生的执行计划就很可能不是当前情况下的最优执行计划了。

为了解决RBO的上述先天缺陷，从Oracle 7开始，Oracle 就引入了CBO。之前已经提到过，CBO在选择目标SQL的执行计划时，所用的判断原则为成本，CBO会从目标SQL诸多可能的执行路径中选择一条成本值最小的执行路径来作为其执行计划，各条执行路径的成本值是根据目标SQL语句所涉及的表、索引、列等相关对象的统计信息计算出来的。

这里的成本是指Oracle根据相关对象的统计信息计算出来的一个值，它实际上代表了Oracle根据相关统计信息估算出来的目标SQL的对应执行步骤的I/O、CPU和网络资源的消耗量，这也就意味着Oracle数据库里的成本实际，上就是对执行目标SQL所要耗费的I/O、CPU和网络资源的一个估算值。

CBO会认为那些消耗系统I/O和CPU资源最少的执行路径就是当前情况下的最佳选择。

接下来介绍CBO的一些基本概念。

#### 3.2.2.1 Cardinality

**集的势**，表示对目标SQL的某个具体执行步骤的执行结果所包含记录数的估算。如果是针对整个目标SQL，那么表示对该SQL最终执行结果所包含记录数的估算。

Cardinality和成本值的估算是息息相关的，因为Oracle得到指定结果集所需要耗费的IO资源可以近似看作随着该结果集所包含记录数的递增而递增，所以某个执行步骤所对应的Cardinality 的值越大，那么它所对应的成本值往往也就越大，这个执行步骤所在执行路径的总成本值也就会越大。

在执行计划种，Cardinality的值对应Rows记录

#### 3.2.2.2 Selectivity

**可选择率**，是CBO特有的概念，是指世家特定谓词条件后返回结果集的记录数占未施加任何谓词条件的原始结果集的记录数的比率。用公式表示为：

![image-20221101104758856](oracle数据库性能优化.assets/image-20221101104758856.png)

Selectivity的值在0~1之间，**值越小，可选择性越高**，即当值为1时选择性是最差的。

可选择率和成本值的估算也是息息相关的，因为**可选择率的值越大，就意味着返回结果集的Cardinality的值就越大，所以估算出来的成本值也就会越大**。

#### 3.2.2.3 Transitivity

**可传递性**，也是CBO特有的概念（RBO不适用），是在查询转换中所做的第一步操作，CBO可能会对原目标SQL做简单的等价改写，根据谓词条件推算出新的谓词条件，目的是提供更多的执行路径给CBO做选择，进而增加得到更高效执行计划的可能性。

1. **简单谓词传递**

   ```sql
   t1.a = t2.a and t1.a = 10
   CBO可能会修改为：
   t1.a = t2.a and t1.a = 10 and t2.a = 10
   ```

2. **连接谓词传递**

   ```sql
   t1.a = t2.a and t2.a = t3.a
   CBO可能会修改为：
   t1.a = t2.a and t2.a = t3.a and t1.a = t3.a
   ```

3. **外连接谓词传递**

   ```sql
   t1.a = t2.a(+) and t1.a = 10
   CBO可能会修改为：
   t1.a = t2.a(+) and t1.a = 10 and t2.a(+) = 10
   ```

   ```sql
   from t1 left join t2 on t1.a = t2.a and t1.a = 10
   CBO可能会修改为：
   from t1 left join t2 on t1.a = t2.a and t1.a = 10 and t2.a = 10
   ```

#### 3.2.2.4 CBO的局限性

1. CBO会默认目标SQL语句where条件中出现的各个列之间是独立的，没有关联关系;
2. CBO会假设所有目标SQL都是独立执行的，而且互不干扰;
3. CBO对直方图统计信息有很多限制
4. CBO在解析多表关联的目标SQL时，可能会漏选正确的执行计划

## 3.3 优化器的基础知识

### 3.3.1 优化器的模式

在Oracle数据库中，优化器的模式是由参数OPTIMIZER_ MODE的值来决定的。

#### 3.3.1.1 RULE

表示oracle将使用RBO来解析目标SQL，此时目标SQL中涉及的各个对象的统计信息对于RBO来说没有任何作用。

#### 3.3.1.2 CHOOSE

CHOOSE是Oracle 9i中OPTIMIZER_ MODE的默认值，它表示Oracle在解析目标SQL时到底是使用RBO还是使用CBO取决于该SQL中所涉及的表对象是否有统计信息。具体来说就是:只要该SQL中所涉及的表对象中有一个有统计信息，那么Oracle在解析该SQL时就会使用CBO；如果该SQL中所涉及的所有表对象均没有统计信息，那么此时Oracle就会使用RBO。

#### 3.3.1.3 FIRST_ROW_n（n=1，10，100，1000）

当OPTIMIZER_ MODE的值为FIRST_ ROWS_ n(n=1, 10,100,1000)时，Oracle会使用CBO来解析目标SQL，且此时CBO在计算该SQL的各条执行路径的成本值时的侧重点在于以最快的响应速度返回头n (n=1, 10, 100, 1000)条记录。

当OPTIMIZER_ MODE的值为FIRST_ ROWS_ n(n= 1, 10, 100, 1000)时，Oracle会把那些能够以最快的响应速度返回头n(n= 1, 10, 100,1000)条记录所对应的执行步骤的成本值修改成一个很小的值(远远小于默认情况下CBO对同样执行步骤所计算出的成本值)。这样Oracle就既没有违背CBO选取执行计划的总原则(成本值最小)，同时又兼顾了FIRST_ ROWS_ n (n= 1, 10, 100, 1000)的含义。

#### 3.3.1.4 FIRST_ROWS

Oracle在解析目标SQL时会联合使用CBO和RBO。和RBO。这里联合使用CBO和RBO的含义是指在大多数情况下，FIRST_ROWS还是会使用CBO来解析目标SQL，且此时CBO在计算该SQL的各条执行路径的成本值时的侧重点在于以最快的响应速度返回头几条记录(类似于FIRST_ _ROWS_ n)；但是，当出现了一些特定情况时，FIRST_ ROWS转而会使用RBO中的一些内置的规则来选取执行计划而不再考虑成本。

#### 3.3.1.5 ALL_ROWS

ALL_ ROWS是Oracle 10g 以及后续Oracle数据库版本中OPTIMIZER_MODE的默认值，它表示Oracle会使用CBO来解析目标SQL，且此时CBO在计算该SQL的各条执行路径的成本值时的侧重点在于最佳的吞吐量(即最小的系统I/O和CPU资源的消耗量)。

成本的计算方法随着优化器模式的不同而不同，主要体现在ALL_ROWS和FIRST_ROW_n对成本值计算方法的影响上。当优化器的模式为ALL_ROWS时，CBO的计算成本侧重点在于最佳的吞吐量；而为FIRST_ROW_n（n=1，10，100，1000）时，计算成本的侧重点会变为以最快的响应速度返回头（n=1，10，100，1000）条记录。这两种模式计算出来的成本值存在着巨大差异，说明优化器的模式对CBO计算成本（进而对CBO选择执行计划）有着决定性的影响。

### 3.3.2 Row Source

结果集，指包含指定执行结果的集合，对于优化器而言（RBO/CBO），结果集和目标执行计划的执行步骤相对应，一个执行计划所产生的执行结果就是该执行步骤所对应的输出结果集。

对于CBO，对应执行计划中的字段ROWS反映的就是CBO对于相关执行步骤输出结果集的记录数（即Cardinality）的估算值。

### 3.3.3 访问数据的方法

Oracle访问数据的方法有两种：一是直接访问表；二是先访问索引，然后再回表，但如果目标SQL所要访问的数据只通过访问相关的索引就可以得到，那么此时就不需要再回表了。

#### 3.3.3.1 访问表的方法

直接访问表的方法有两种：一是全表扫描；二是ROWID扫描。

##### 3.3.3.1.1 全表扫描

全表扫描是指Oracle 在访问目标表里的数据时，会从该表所占用的第一个区(EXTENT) 的第一个块( BLOCK)开始扫描，一直扫描到该表的高水位线( HWM, High Water Mark)，这段范围内所有的数据块Oracle都必须读到。当然，Oracle会对这期间读到的所有数据施加目标SQL的where条件中指定的过滤条件，最后只返回那些满足过滤条件的数据。

当目标表的数据量不是很大时，全表扫描的方式的执行效率很高，但也存在执行时间不稳定的问题，且执行时间随着表的数据量的增大而增加。因为数据量增大，高水位线会上涨，全表扫描所需要耗费的I/O资源随之增加，导致CBO成本值增加。

高水位线的这种特性所带来的副作用是,即使使用DELETE语句删光了目标表中的所有数据，高水位线还是会在原来的位置，这意味着全表扫描该表时Oracle还是需要扫描该表高水位线下的所有数据块，所以此时对该表的全表扫描操作所耗费的时间与之前相比并不会有明显的改观。**全表扫描所花费的时间会随着目标表数据量的递增而递增**。

##### 3.3.3.1.1 ROWID 扫描

ROWID是记录所在的物理地址，与数据块中的记录一一对应，具有唯一性。

ROWID扫描是指Oracle访问目标表里的数据时，直接通过数据所在的ROWID去定位并访问这些数据。

ROWID扫描有两种方式：一是在SQL语句中输入ROWID的值直接去访问对应的记录；二是先去访问相关的索引，然后根据得到的ROWID再回表访问对应的记录。

获取记录对应的ROWID方式：

```sql
SQL> select empno,rowid from emp;

     EMPNO ROWID
---------- ------------------
      7369 AAAFCOAABAAALDxAAA
      7499 AAAFCOAABAAALDxAAB

SQL> select * from emp where rowid = 'AAAFCOAABAAALDxAAA';

     EMPNO ENAME                JOB                       MGR HIREDATE              SAL       COMM     DEPTNO
---------- -------------------- ------------------ ---------- -------------- ---------- ---------- ----------
      7369 SMITH                CLERK                    7902 17-12月-80            800                    20
```

#### 3.3.3.2 访问索引的方式 ★

B树索引是oracle中最常用的索引。B树索引结构主要由三部分组成根节点、分支节点、叶子节点。 B树索引就是 一颗二叉树；叶子节点（双向链表）包含索引列和指向表中每个匹配行的rowid值。所有叶子节点具有相同的深度，因而不管查询条件怎样，查询速度基本相同。B树索引结构能够适应精确查询（=）、模糊查询（like）和比较查询（>）。

![image-20221104162302627](oracle数据库性能优化.assets/image-20221104162302627.png)

B树索引包含两种类型的数据块，一是索引分支块，而是索引叶子块。在Oracle里访问B树索引必须从根节点开始，到分支快，再到叶子块。

**索引分支块**包含指向相应索引分支块/叶子块的指针和索引键值列（这里的指针是指相关分支块/叶子块的块地址RDBA。每个索引分支块都会有两种类型的指针，一种是 **Imc**，另一种是**索引分支块的索引行记录所记录的指针**。Imc 是Left Most Child的缩写，**每个索引分支块都只有一个Imc**，**这个Imc指向的分支块/叶子块中的所有索引键值列中的最大值一定小于该lmc所在索引分支块的所有索引键值列中的最小值**；**而索引分支块的索引行记录所记录的指针所指向的分支块/叶子块的所有索引键值列中的最小值一定大于或等于该行记录的索引键值列的值**）。

**索引叶子块**包含被索引键值和ROWID。对于唯一性B数索引，ROWID是存储在索引行的行头，此时不需要额外存储ROWID长度。而对于非唯一性的B树索引，ROWID额外作为一个字段与键值列一起存储，此时既要存储ROWID，也要存储ROWID的长度。索引叶子块是左右互联的，即相当于有一个双向指针链表把这些索引叶子块相互连接在一起。

基于上述结构，**B数索引有以下优点**：

1. 所有的索引叶子块都在同一层，即它们距离索引根节点的深度是相同的。这也意味着访问索引叶子块的任何一个索引键值所花费的时间几乎相同。
2. Oracle 会保证所有的B树索引都是自平衡的，即不可能出现不同的索引叶子块不处于同一层的现象。
3. **通过B树索引访问表里行记录的效率并不会随着相关表的数据量的递增而显著降低，即通过走索引访问数据的时间是可控的、基本稳定的，这也是走索引和全表扫描的最大区别**。全表扫描最大的劣势就在于其访问时间不可控，不稳定，即全表扫描所花费的时间会随着目标表数据量的递增而递增。

通过B树索引访问数据的过程是先访问相关的B树索引，根据访问的索引得到的ROWID再回表去访问对应的记录。**访问B树索引要耗费两次I/O**（全表扫描只需要耗费一次I/O），一是访问相关的B树索引的成本（从根节点定位到相关的分支块，再定位到相关的叶子块，最后对这些叶子块执行扫描操作）;二是回表的成本（根据得到的ROWID再回表去扫描对应的数据行所在的数据块）。

##### 3.3.3.2.1 INDEX UNIQUE SCAN

索引唯一性扫描，是针对唯一性索引（UNIQUE INDEX）的扫描，仅仅适用于WHERE条件里的等值查询。

因为扫描对象是唯一性索引，索引得到的结果至多只有一条记录。

##### 3.3.3.2.2 INDEX RANG SCAN

索引范围扫描适用于所有类型的B树索引，当扫描的对象是唯一性索引时， 此时目标SQL的where条件一定是范围查询（谓词条件为BETWEEN、<.>等）；当扫描的对象是非唯一性索引时，对目标SQL的where条件没有限制（可以是等值查询，也可以是范围查询）。索引范围扫描的结果可能会返回多条记录，其实这就是索引范围扫描中”范围“二字的本质含义。

需要注意的是，即使是针对同等条件下的相同SQL，当目标索引的索引行的数量大于1时，索引范围扫描所耗费的逻辑读会多于索引唯一性扫描所耗费的逻辑读。这是因为索引唯一性扫描的扫描结果至多只会返回条记录，所以Oracle 明确知道此时只需要访问相关的叶子块一次就可以直接返回了；但对于索引范围扫描而言，因为其扫描结果可能会返回多条记录，同时又因为目标索引的索引行数量大于1，Oracle 为了确定索引范围扫描的扫描终点，就不得不去多次访问相关的叶子块，**所以在同等条件下，当目标索引的索引行的数量大于1时，索引范围扫描所耗费的逻辑读至少会比相应的索引唯一性扫描的逻辑读多1**。

##### 3.3.3.2.3 INDEX FULL SCAN

索引全扫描，适用于所有类型的B树索引（包括唯一性索引和非唯一性索引），指要扫描目标索引所有叶子块的所有索引行。需要注意的是，索引全扫描需要扫描目标索引的所有叶子块，但这并不意味着需要扫描该索引的所有分支块。在默认情况下，Oracle 在做索引全扫描时只需要通过访问必要的分支块定位到位于该索引最左边的叶子块的第一行索引行，就可以利用该索引叶子块之间的双向指针链表，从左至右依次顺序扫描该索引所有叶子块的所有索引行了。

既然在默认情况下，索引全扫描要从左至右依次顺序扫描目标索引所有叶子块的所有索引行，而索引是有序的，**所以索引全扫描的执行结果也是有序的，并且是按照该索引的索引键值列来排序，这也意味着走索引全扫描能够既达到排序的效果，又同时避免了对该索引的索引键值列的真正排序操作**。

##### 3.3.3.2.4 INDEX FAST FULL SCAN

索引快速全扫描，和索引全扫描的特性类似，主要有一下三点区别：

1. INDEX FAST FULL SCAN只适用于CBO；
2. INDEX FAST FULL SCAN可以使用多块读，也可以并行执行；
3. INDEX FAST FULL SCAN的执行结果不一定是有序的。这是因为索引快速全扫描时Oracle是根据索引行在磁盘上的物理存储顺序来扫描，而不是根据索引行的逻辑顺序来扫描的，所以扫描结果才不一-定有序（对于单个索引叶子块中的索引行而言，其物理存储顺序和逻辑存储顺序一致；但对于物理存储位置相邻的索引叶子块而言，块与块之间索引行的物理存储顺序则不一 定在逻辑上有序）。

##### 3.3.3.2.5 INDEX SKIP SCAN

索引跳跃式扫描，适用于所有类型的**复合B树索引**（包括唯一性索引和非唯一性索引），它使那些在where条件中没有对目标索引的前导列指定查询条件但同时又对该索引的非前导列指定了查询条件的目标SQL依然可以用上该索引，这就像是在扫描该索引时跳过了它的前导列，直接从该索引的非前
导列开始扫描一样(实际的执行过程并非如此），这也是索引跳跃式扫描中”跳跃“（SKIP）一词的含义。
为什么在where条件中没有对目标索引的前导列指定查询条件但Oracle依然可以用上该索引呢？这是因为Oracle帮你对该索引的前导列的所有distinct值做了遍历。

**Oracle中的索引跳跃式扫描仅仅适用于那些目标索引前导列的distinct值数量较少、后续非前导列的可选择性又非常好的情形，因为索引跳跃式扫描的执行效率一定会 随着目标索引前导列的distinct值数量的递增而递减**。

#### 3.3.3.3 表连接

顾名思义，表连接就是指**多个表**之间用**连接条件**连接在一起，使用表连接的目标SQL的目的就是从多个表获取存储在这些表中的**不同维度的数据**。体现在SQL语句上，含表连接的目标SQL的**from部分会出现多个表**，而这些SQL的**where条件部分则会定义具体的表连接条件**。

当优化器解析含表连接的目标SQL时，它除了会根据目标SQL的SQL文本的写法来决定表连接的类型之外，还必须决定如下三件事情才能得到最终的执行计划。

**1. 表连接顺序**

**不管目标SQL中有多少个表做表连接，Oracle 在实际执行该SQL时都只能先两两做表连接，再依次执行这样的两两表连接过程，直到目标SQL中所有的表都已连接完毕。**所以从严格意义上来说，这里的表连接顺序包含两层含义：第一层含义是当两个表做表连接时，优化器需要决定这两个表中谁是**驱动表**(outer table)，谁是**被驱动表**(inner table)；另外一层含义是当多表( 超过两个以上的表)做表连接时，优化器需要决定这些
表中谁和谁先做表连接,然后决定这个表连接结果所在的结果集再和剩余表中的哪一一个再做表连接,这个两两
做表连接的过程会-直持续下去， 直到目标SQL中所有的表都已连接完为止。

**2. 表连接方法**

在Oracle 数据库中，两个表之间的表连接方法有排序合并连接、嵌套循环连接、哈希连接和笛卡儿连接这四种，所以优化器在解析含表连接的目标SQL时，都需要从上述四种方法中选择一种，作为每两张表两两做表连接时所需要采用的方法。

**3. 访问单表的方法**

全表扫描或走索引。

##### 3.3.3.3.1 表连接的类型

sql脚本的写法直接决定表连接的类型，表连接类型直接决定表连接的结果。

```sql
-- 测试表
SQL> desc t;
Name Type     Nullable Default Comments 
---- ------------ -------- ------- -------- 
COL1 NUMBER Y                        
COL2 VARCHAR2(10) Y

SQL> desc t2;
Name Type     Nullable Default Comments 
---- ------------ -------- ------- -------- 
COL1 NUMBER Y                        
COL2 VARCHAR2(10) Y 
```

###### 3.3.3.3.1.1 内连接

Inner Join，**查询结果只返回那些完全满足连接条件的记**录。

![image-20221107163120176](oracle数据库性能优化.assets/image-20221107163120176.png)

```sql
SQL> SELECT t.*,t2.* from t left join t2 on t.col1 = t2.col1;

      COL1 COL2         COL1 COL2
---------- ---------- ---------- ----------
         1 a                  1 a
         2 b                  2 b
         3 c                    
```

###### 3.3.3.3.1.2 外连接

Outer Join，查询结果除了**返回那些完全满足连接条件的记录**之外，还包含**驱动表中所有不满足连接条件的记录**。被驱动表中不满足连接条件的字段会以NULL值填充。

1. left join

   ```sql
   驱动表 left join 被驱动表 on (连接条件)
   ```

   ```sql
   SQL> SELECT t.*,t2.* from t left join t2 on t.col1 = t2.col1;
   
         COL1 COL2         COL1 COL2
   ---------- ---------- ---------- ----------
            1 a                  1 a
            2 b                  2 b
            3 c                    
   ```

2. right join

   ```sql
   被驱动表 right join 驱动表 on (连接条件)
   ```

   ```sql
   SQL> SELECT t.*,t2.* from t right join t2 on t.col1 = t2.col1;
   
         COL1 COL2         COL1 COL2
   ---------- ---------- ---------- ----------
            1 a                  1 a
            2 b                  2 b
                                 4 d
   ```

3. full join

   ```sql
   驱动表 full join 驱动表 on (连接条件)
   ```

   全外连接是左外连接和右外连接的集合：

   ```sql
   驱动表 left join 驱动表 on (连接条件)
   union
   驱动表 right join 驱动表 on (连接条件)
   ```

   ```sql
   SQL>  SELECT t.*,t2.* from t full join t2 on t.col1 = t2.col1;
   
         COL1 COL2         COL1 COL2
   ---------- ---------- ---------- ----------
            1 a                  1 a
            2 b                  2 b
                                 4 d
            3 c                   
   ```

##### 3.3.3.3.2 表连接的方法 ★

###### 3.3.3.3.2.1 Sort Merge Join

排序合并连接，是一种两个表做表连接时用排序操作（sort）和合并操作（meger）来得到连接结果的表连接方法。

如果两个表（这里将它们分别命名为表T1和表T2）在做表连接时使用的是排序合并连接，则Oracle 会依次顺序执行如下**步骤：**

1. 首先以目标SQL中指定的谓词条件（如果有的话）去访问表T1，然后对访问结果按照表T1中的连接列来排序，排好序后的结果集我们记为结果集1。
2. 接着以目标SQL中指定的谓词条件（ 如果有的话）去访问表T2，然后对访问结果按照表T2中的连接列来排序，排好序后的结果集我们记为结果集2。
3. 最后对结果集1和结果集2执行合并操作，从中取出匹配记录来作为排序合并连接的最终执行结果。
   合并操作也可以理解为：首先遍历结果集1，即先取出结果集1中的第1条记录，然后去结果集2中按照连接条件判断是否存在匹配记录，然后再取出结果集1中的第2条记录，按照同样的连接条件再去结果集2中判断是否存在匹配的记录，直到最后遍历完结果集1中所有的记录。

**排序合并连接特性：**

- 通常情况下，排序合并连接的执行效率比不上哈希连接，但是使用场景更广（<、<=、>、>=）,而哈希连接通常只能用于等值连接 ；
- 通常情况下，排序合并连接并不适合OLTP类型的系统，因为排序在OLTP系统中十分费劲，如果能避免排序操作，排序合并链接也可以在OLTP系统中使用；
- 从严格意义上来说，排序合并连接不存在驱动表的概念，但我认为还是存在驱动表和被驱动表的。

###### 3.3.3.3.2.2 Nested Loops Join

**嵌套循环连接**，是一种两个表在做表连接时依靠两层嵌套循环（分别为外层循环和内
层循环）来得到连接结果集的表连接方法。

测试表T1和T2做嵌套循环连接的具体的执行**步骤**为：

1. 首先，优化器会按照规则决定T1和T2谁是驱动表、被驱动表。驱动表处于外层循环，被驱动表处于内层循环。这里假设驱动表是T1,被驱动表是T2；
2. 接着根据谓词条件去访问驱动表T1，得到结果集1；
3. 然后在遍历结果集1的同时遍历被驱动表T2（先取出结果集1中的第一条记录，接着去遍历被驱动表T2，判断T2中是否存在匹配的记录。然后再取出结果集1的第二条记录，...，直到遍历完结果集1中所有的记录为止）。
   这里的外层循环是遍历结果集1的循环，内层循环是遍历被驱动表T2的循环。**所以，外层所对应的驱动结果集1有多少条记录，就要进行多少次内层循环。**

**嵌套循环连接特性：**

- **如果驱动表所对应的驱动结果集的记录数较少，同时在被驱动表的连接列上又存在唯一性索引（或者在被驱动表的连接列上存在选择性很好的非唯一性索引），那么此时使用嵌套循环连接的执行效率就会非常高；但如果驱动表所对应的驱动结果集的记录数很多，即便在被驱动表的连接列上存在索引，此时使用嵌套循环连接的执行效率也不会高。**
- 只要驱动结果集的记录数较少，那就具备了做嵌套循环连接的前提条件，而驱动结果集是在对驱动表应用了目标SQL中指定的谓词条件（如果有的话）后所得到的结果集，**所以大表也可以作为嵌套循环连接的驱动表，关键看目标SQL中指定的谓词条件（如果有的话）能否将驱动结果集的数据量降下来。**
- **嵌套循环连接有其他连接方法所没有的一个优点：嵌套循环连接可以实现快速响应**，即它可以第一时间先返回已经连接过且满足连接条件的记录，而不必等待所有的连接操作全部做完后才返回连接结果。

###### 3.3.3.3.2.3 Hash Join

**哈希连接**，两张表做表连接时主要依靠**哈希运算**来得到连接结果集的表连接方法。

###### 3.3.3.3.2.4 Cross Join



# 四、执行计划

# 五、查询转换

# 六、统计信息

# 七、Hint



获取字段优先级

```sql
select t.table_name,t.column_name,t.num_distinct
from user_tab_col_statistics t
where t.table_name = 'EMP'
order by 2 desc;
```

获取索引优先级

```sql
SELECT T.INDEX_NAME,T.NUM_ROWS
FROM USER_INDEXES T
WHERE T.TABLE_NAME = 'EMP'
ORDER BY T.NUM_ROWS DESC;
```

